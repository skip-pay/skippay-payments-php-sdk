<?php

/**
 * ObjectSerializer
 *
 * Skip Pay API for partners
 *
 * API documentation for Skip Pay partners.
 *
 * The version of the OpenAPI document: 1.0
 * Contact: info@skippay.cz
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.6.0

 *
 * @category Class
 * @package  SkipPay
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace SkipPay;

use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Query;
use GuzzleHttp\Psr7\Request;
use SkipPay\Model\ModelInterface;

/**
 * ObjectSerializer Class Doc Comment
 *
 * @category Class
 * @package  SkipPay
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class ObjectSerializer
{
    /** @var string */
    private static $dateTimeFormat = \DateTimeInterface::ATOM;

    /**
     * Change the date format
     *
     * @param string $format
     *   The new date format to use.
     */
    public static function setDateTimeFormat($format)
    {
        self::$dateTimeFormat = $format;
    }

    /**
     * Serialize data
     *
     * @param mixed  $data   the data to serialize
     * @param string $type   the OpenAPIToolsType of the data
     * @param string $format the format of the OpenAPITools type of the data
     *
     * @return scalar|object|mixed[]|null serialized form of $data
     */
    public static function sanitizeForSerialization($data, $type = null, $format = null)
    {
        if (is_scalar($data) || null === $data) {
            return $data;
        }

        if ($data instanceof \DateTime) {
            return ($format === 'date') ? $data->format('Y-m-d') : $data->format(self::$dateTimeFormat);
        }

        if (is_array($data)) {
            foreach ($data as $property => $value) {
                $data[$property] = self::sanitizeForSerialization($value);
            }
            return $data;
        }

        if (is_object($data)) {
            $values = [];
            if ($data instanceof ModelInterface) {
                // TODO These additional properties should probably be "sanitized".
                $values = $data->getAdditionalProperties() ?: [];
                $formats = $data::openAPIFormats();
                foreach ($data::openAPITypes() as $property => $openAPIType) {
                    $getter = $data::getters()[$property];
                    $value = $data->$getter();
                    if ($value !== null && !in_array($openAPIType, ['\DateTime', '\SplFileObject', 'array', 'bool', 'boolean', 'byte', 'float', 'int', 'integer', 'mixed', 'number', 'object', 'string', 'void'], true)) {
                        $callable = [$openAPIType, 'getAllowableEnumValues'];
                        if (is_callable($callable)) {
                            /** array $callable */
                            $allowedEnumTypes = $callable();
                            if (!in_array($value, $allowedEnumTypes, true)) {
                                $imploded = implode("', '", $allowedEnumTypes);
                                throw new \InvalidArgumentException("Invalid value for enum '$openAPIType', must be one of: '$imploded'");
                            }
                        }
                    }
                    if ($value !== null) {
                        $values[$data::attributeMap()[$property]] = self::sanitizeForSerialization($value, $openAPIType, $formats[$property]);
                    }
                }
            } elseif (is_iterable($data)) {
                foreach ($data as $property => $value) {
                    $values[$property] = self::sanitizeForSerialization($value);
                }
            } elseif ($data instanceof \stdClass) {
                return $data;
            }
            return (object)$values;
        } else {
            return (string)$data;
        }
    }

    /**
     * Sanitize filename by removing path.
     * e.g. ../../sun.gif becomes sun.gif
     *
     * @param string $filename filename to be sanitized
     *
     * @return string the sanitized filename
     */
    public static function sanitizeFilename($filename)
    {
        if (preg_match("/.*[\/\\\\](.*)$/", $filename, $match)) {
            return $match[1];
        } else {
            return $filename;
        }
    }

    /**
     * Take value and turn it into a string suitable for inclusion in
     * the path, by url-encoding.
     *
     * @param scalar[]|scalar|\DateTime $value a value which will be part of the path
     *
     * @return string the serialized object
     */
    public static function toPathValue($value)
    {
        if (is_array($value)) {
            $value = implode(',', $value);
        }
        return rawurlencode(self::toString($value));
    }

    /**
     * Take value and turn it into a string suitable for inclusion in
     * the query, by imploding comma-separated if it's an object.
     * If it's a string, pass through unchanged. It will be url-encoded
     * later.
     *
     * @param scalar[]|scalar|\DateTime $object an object to be serialized to a string
     *
     * @return string|null A serialized query parameter. Null to skip.
     */
    public static function toQueryValue($object)
    {
        if (is_array($object)) {
            return implode(',', $object);
        }
        return self::toString($object);
    }

    /**
     * Process values and prep them for Guzzle query serialization.
     *
     * @param string $name
     *   Query parameter name.
     * @param mixed $value
     *   Query parameter value.
     * @param string $style
     *   Query parameter style.
     *
     * @return array<string, string>
     *   A hash of values keyed by the query parameter name(s).
     */
    public static function processQuery(string $name, $value, string $style): array
    {
        if ($style === 'form' && is_array($value)) {
            return $value;
        }
        return [$name => static::toString($value)];
    }

    /**
     * Take value and turn it into a string suitable for inclusion in
     * the header. If it's a string, pass through unchanged
     * If it's a datetime object, format it in ISO8601
     *
     * @param \SkipPay\Model\ModelInterface|scalar $value a string which will be part of the header.
     *
     * @return string the header string
     */
    public static function toHeaderValue($value)
    {
        if ($value instanceof ModelInterface) {
            /**
             * @todo remove when Guzzle 6 support is removed.
             * @psalm-suppress DeprecatedFunction
             */
            return \GuzzleHttp\json_encode(static::sanitizeForSerialization($value));
        }
        return self::toString($value);
    }

    /**
     * Convert file parameter(s) to format expected by guzzle.
     *
     * @param string|\SplFileObject|array<string|\SplFileObject> $file the value of the form parameter
     *
     * @return resource[] File resources
     */
    public static function fileToFormValue($file): array
    {
        $paramFiles = is_array($file) ? $file : [$file];
        $return = [];
        foreach ($paramFiles as $paramFile) {
            $return[] = \GuzzleHttp\Psr7\Utils::tryFopen(
                ObjectSerializer::toFormValue($paramFile),
                'rb'
            );
        }
        return $return;
    }

    /**
     * Take value and turn it into a string suitable for inclusion in
     * the http body (form parameter). If it's a string, pass through unchanged
     * If it's a datetime object, format it in ISO8601
     *
     * @param string|\SplFileObject $value the value of the form parameter
     *
     * @return string the form string
     * @throws \SkipPay\ApiException
     */
    public static function toFormValue($value)
    {
        if ($value instanceof \SplFileObject) {
            $path = $value->getRealPath();
            if ($path === false) {
                throw new ApiException('Unable to find file.');
            }
            return $path;
        }
        return self::toString($value);
    }

    /**
     * Take value and turn it into a string suitable for inclusion in
     * the parameter. If it's a string, pass through unchanged
     * If it's a datetime object, format it in ISO8601
     * If it's a boolean, convert it to "true" or "false".
     *
     * @param scalar|\DateTime $value the value of the parameter
     *
     * @return string the header string
     */
    public static function toString($value)
    {
        if ($value instanceof \DateTime) { // datetime in ISO8601 format
            return $value->format(self::$dateTimeFormat);
        } elseif (is_bool($value)) {
            return $value ? 'true' : 'false';
        }
        return (string) $value;
    }

    /**
     * Convert body object into transferable string.
     *
     * @param mixed $object Body object
     * @param string $contentType The expected body content type.
     * @return string Encoded body value.
     */
    public static function toBodyValue($object, string $contentType): string
    {
        if ($contentType === 'application/json') {
            /**
             * @todo remove when Guzzle 6 support is removed.
             * @psalm-suppress DeprecatedFunction
             */
            return \GuzzleHttp\json_encode(static::sanitizeForSerialization($object));
        } elseif (!is_array($object)) {
            return (string) $object;
        }
        return '';
    }

    /**
     * Serialize an array to a string.
     *
     * @param scalar[] $collection Collection to serialize to a string.
     * @param string $style The format use for serialization (csv, ssv, tsv, pipes, multi)
     * @param bool $allowCollectionFormatMulti Allow collection format to be a multidimensional array.
     *
     * @throws \SkipPay\ApiException
     * @return string
     */
    public static function serializeCollection(array $collection, $style, $allowCollectionFormatMulti = false)
    {
        if ($allowCollectionFormatMulti && ('multi' === $style)) {
            // http_build_query() almost does the job for us. We just
            // need to fix the result of multidimensional arrays.
            $string = preg_replace('/%5B[0-9]+%5D=/', '=', http_build_query($collection, '', '&'));
            if ($string === null) {
                throw new ApiException('Unable to serialize collection');
            }
            return $string;
        }
        switch ($style) {
            case 'pipeDelimited':
            case 'pipes':
                return implode('|', $collection);

            case 'tsv':
                return implode("\t", $collection);

            case 'spaceDelimited':
            case 'ssv':
                return implode(' ', $collection);

            case 'simple':
            case 'csv':
                // Deliberate fall through. CSV is default format.
            default:
                return implode(',', $collection);
        }
    }

    /**
     * Deserialize a JSON string into an object
     *
     * @template T
     * @param mixed $data object or primitive to be deserialized
     * @param string $type Some php type that be returned.
     * @param array<array-key, string[]> $httpHeaders A list of headers from the response.
     * @phpstan-param class-string<T> $type
     *
     * @return mixed a single or an array of $type instances
     * @phpstan-return ($data is null ? null : T)
     * @throws \SkipPay\ApiException
     */
    public static function deserialize($data, $type, $httpHeaders = null)
    {
        if (null === $data) {
            return null;
        }

        $t = $type;
        if ($t === \SplFileObject::class) {
            /** @var \Psr\Http\Message\StreamInterface $data */

            // determine file name
            if (
                isset($httpHeaders['Content-Disposition'][0]) &&
                preg_match('/inline; filename=[\'"]?([^\'"\s]+)[\'"]?$/i', $httpHeaders['Content-Disposition'][0], $match)
            ) {
                $filename = Configuration::getDefaultConfiguration()->getTempFolderPath() . DIRECTORY_SEPARATOR . self::sanitizeFilename($match[1]);
            } else {
                $filename = tempnam(Configuration::getDefaultConfiguration()->getTempFolderPath(), '');
                if ($filename === false) {
                    throw new ApiException('Unable to create temporary directory');
                }
            }

            $file = fopen($filename, 'w');
            if ($file === false) {
                throw new ApiException('Unable to write temporary file');
            }
            while ($chunk = $data->read(200)) {
                fwrite($file, $chunk);
            }
            fclose($file);

            return new $type($filename, 'r');
        }

        // @todo support more content types.
        $data = $data instanceof \Psr\Http\Message\StreamInterface ? (string) $data : $data;
        if (!empty($data) && is_string($data)) {
            try {
                $data = json_decode($data, null, 512, JSON_THROW_ON_ERROR);
            } catch (\ValueError | \JsonException $e) {
                throw new ApiException('Error decoding json: ' . $data, 0, [], null, $e);
            }
        }
        return $data ? static::doDeserialize($data, $type) : null;
    }

    /**
     * Deserialize a JSON string into an object
     *
     * @param mixed  $data object or primitive to be deserialized
     * @param string $type class name is passed as a string
     *
     * @return mixed a single or an array of $type instances
     */
    public static function doDeserialize($data, string $type)
    {
        // json deserialization failed, don't continue.
        if (null === $data) {
            return null;
        }

        if (strcasecmp(substr($type, -2), '[]') === 0) {
            if (!is_array($data)) {
                throw new \InvalidArgumentException("Invalid array '$type'");
            }

            /** @var class-string $subType */
            $subType = substr($type, 0, -2);
            $values = [];
            foreach ($data as $key => $value) {
                $values[] = self::doDeserialize($value, $subType);
            }
            return $values;
        }

        // for associative array e.g. array<string,int>
        if (preg_match('/^(array<|map\[)/', $type)) {
            settype($data, 'array');
            $inner = substr($type, 4, -1);
            $deserialized = [];
            if (strrpos($inner, ",") !== false) {
                $subType_array = explode(',', $inner, 2);
                /** @var class-string $subType */
                $subType = $subType_array[1];
                foreach ($data as $key => $value) {
                    $deserialized[$key] = self::doDeserialize($value, $subType);
                }
            }
            return $deserialized;
        }

        if ($type === '\DateTime') {
            // Some API's return an invalid, empty string as a
            // date-time property. DateTime::__construct() will return
            // the current time for empty input which is probably not
            // what is meant. The invalid empty string is probably to
            // be interpreted as a missing field/value. Let's handle
            // this graceful.
            if (!empty($data)) {
                try {
                    return new \DateTime($data);
                } catch (\Exception $exception) {
                    // Some API's return a date-time with too high nanosecond
                    // precision for php's DateTime to handle. This conversion
                    // (string -> unix timestamp -> DateTime) is a workaround
                    // for the problem.
                    return (new \DateTime())->setTimestamp(strtotime($data));
                }
            } else {
                return null;
            }
        }

        /** @psalm-suppress ParadoxicalCondition */
        if (in_array($type, ['\DateTime', '\SplFileObject', 'array', 'bool', 'boolean', 'byte', 'float', 'int', 'integer', 'mixed', 'number', 'object', 'string', 'void'], true)) {
            settype($data, $type);
            return $data;
        }

        // We couldn't do a scalar cast, so we know this is class string.
        /** @var class-string $type */
        if (method_exists($type, 'getAllowableEnumValues')) {
            if (!in_array($data, $type::getAllowableEnumValues(), true)) {
                $imploded = implode("', '", $type::getAllowableEnumValues());
                throw new \InvalidArgumentException("Invalid value for enum '$type', must be one of: '$imploded'");
            }
            return $data;
        } else {
            if (is_subclass_of($type, ModelInterface::class)) {
                // If a discriminator is defined and points to a valid subclass, use it.
                $discriminator = $type::DISCRIMINATOR;
                if (!empty($discriminator) && isset($data->{$discriminator}) && is_string($data->{$discriminator})) {
                    $subclass = '\Apqc\HeimdallLib\Internal\Swagger\Model\\' . $data->{$discriminator};
                    if (is_subclass_of($subclass, $type)) {
                        $type = $subclass;
                    }
                }
            }
        }

        /** @psalm-suppress MixedMethodCall */
        $instance = new $type();
        if ($instance instanceof ModelInterface) {
            $additional_properties = get_object_vars($data);
            foreach ($instance::openAPITypes() as $property => $model_types) {
                $propertySetter = $instance::setters()[$property];
                unset($additional_properties[$property]);

                if (!isset($data->{$instance::attributeMap()[$property]})) {
                    continue;
                }

                $propertyValue = $data->{$instance::attributeMap()[$property]};
                $instance->$propertySetter(self::doDeserialize(
                    $propertyValue,
                    $model_types
                ));
            }
            // Add any additional properties directly. This doesn't get any
            // fancy serialization which is unfortunate, but it gives us basic
            // access to additional properties.
            foreach ($additional_properties as $property => $value) {
                $instance->setAdditionalProperty($property, $value);
            }
        }
        return $instance;
    }

    /**
     * Create a request from relevant values.
     *
     * @param string $method Request method type.
     * @param string $uri Request uri.
     * @param array<array-key, mixed> $query Query parameters.
     * @param array<string, string|null> $headers Headers.
     * @param array<string|resource[]|null> $form Form parameters.
     * @param mixed $body Body object.
     */
    public static function createRequest(
        string $method,
        string $uri,
        array $query,
        array $headers,
        array $form,
        $body
    ): Request {

        $query = array_filter($query, fn ($v) => $v !== null);
        $query = Query::build($query);
        $headers = array_filter($headers, fn ($v) => $v !== null);
        $form = array_filter($form, fn ($v) => $v !== null);
        assert(empty($form) || empty($body), 'Form parameters will override body.');
        // This is a bit hacky but sometimes APIs aren't great about reporting
        // they need to post multipart data. This detects any file parameters
        // and forces a multipart submission.
        $multipart = array_reduce($form, function (bool $carry, $items): bool {
            if (is_array($items)) {
                foreach ($items as $item) {
                    if (is_resource($item)) {
                        return true;
                    }
                }
            }
            return $carry;
        }, false);
        // @todo probably need to fix the content type if we detected the need
        //   to submit a multipart form.
        if (!empty($form)) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($form as $paramName => $paramValue) {
                    if (is_array($paramValue)) {
                        foreach ($paramValue as $paramValueItem) {
                            $multipartContents[] = [
                                'name' => $paramName,
                                'contents' => $paramValueItem
                            ];
                        }
                    } else {
                        $multipartContents[] = [
                            'name' => $paramName,
                            'contents' => $paramValue
                        ];
                    }
                }
                // for HTTP post (form)
                $body = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                /**
                 * @todo remove when Guzzle 6 support is removed.
                 * @psalm-suppress DeprecatedFunction
                 */
                $body = \GuzzleHttp\json_encode($form);
            } else {
                // for HTTP post (form)
                $body = Query::build($form);
            }
        }
        return new Request(
            $method,
            $uri . ($query ? "?{$query}" : ''),
            $headers,
            !empty($body) ? ObjectSerializer::toBodyValue($body, $headers['Content-Type']) : ''
        );
    }
}
