<?php

/**
 * MerchantUrls
 *
 * Skip Pay API for partners
 *
 * API documentation for Skip Pay partners.
 *
 * The version of the OpenAPI document: 1.0
 * Contact: info@skippay.cz
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.6.0

 *
 * @category Class
 * @package  SkipPay
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace SkipPay\Model;

use ArrayAccess;
use SkipPay\ObjectSerializer;

/**
 * MerchantUrls Class Doc Comment
 *
 * @category Class
 * @description Collection of URLs used for redirection of a customer back to a partner website or as a notification endpoint. Services that should be developed and exposed by partner e-shops to allow Skip Pay to asynchronously inform these partners about important changes regarding particular applications and orders.
 * @package  SkipPay
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<?string, ?mixed>
 */
class MerchantUrls implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'MerchantUrls';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|class-string>
      */
    protected static $openAPITypes = [
        'approvedRedirect' => 'string',
        'rejectedRedirect' => 'string',
        'notificationEndpoint' => 'string',
        'paymentsEndpoint' => 'string',
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'approvedRedirect' => 'url',
        'rejectedRedirect' => 'url',
        'notificationEndpoint' => null,
        'paymentsEndpoint' => 'url',
    ];

    /**
      * Array of additional properties.
      *
      * @var array<array-key, array-key>
      */
    protected $additionalProperties = [];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'approvedRedirect' => 'approvedRedirect',
        'rejectedRedirect' => 'rejectedRedirect',
        'notificationEndpoint' => 'notificationEndpoint',
        'paymentsEndpoint' => 'paymentsEndpoint',
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'approvedRedirect' => 'setApprovedRedirect',
        'rejectedRedirect' => 'setRejectedRedirect',
        'notificationEndpoint' => 'setNotificationEndpoint',
        'paymentsEndpoint' => 'setPaymentsEndpoint',
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'approvedRedirect' => 'getApprovedRedirect',
        'rejectedRedirect' => 'getRejectedRedirect',
        'notificationEndpoint' => 'getNotificationEndpoint',
        'paymentsEndpoint' => 'getPaymentsEndpoint',
    ];

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['approvedRedirect'] = $data['approvedRedirect'] ?? null;
        $this->container['rejectedRedirect'] = $data['rejectedRedirect'] ?? null;
        $this->container['notificationEndpoint'] = $data['notificationEndpoint'] ?? null;
        $this->container['paymentsEndpoint'] = $data['paymentsEndpoint'] ?? null;
    }

    /**
     * {@inheritDoc}
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * {@inheritDoc}
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * {@inheritdoc}
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * {@inheritdoc}
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * {@inheritdoc}
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * {@inheritdoc}
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    /**
     * {@inheritdoc}
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['approvedRedirect'] === null) {
            $invalidProperties['approvedRedirect'] = "'approvedRedirect' can't be null";
        }
        if ((mb_strlen($this->container['approvedRedirect']) > 512)) {
            $invalidProperties[] = "invalid value for 'approvedRedirect', the character length must be smaller than or equal to 512.";
        }

        if ($this->container['rejectedRedirect'] === null) {
            $invalidProperties['rejectedRedirect'] = "'rejectedRedirect' can't be null";
        }
        if ((mb_strlen($this->container['rejectedRedirect']) > 512)) {
            $invalidProperties[] = "invalid value for 'rejectedRedirect', the character length must be smaller than or equal to 512.";
        }

        if ($this->container['notificationEndpoint'] === null) {
            $invalidProperties['notificationEndpoint'] = "'notificationEndpoint' can't be null";
        }
        if ((mb_strlen($this->container['notificationEndpoint']) > 512)) {
            $invalidProperties[] = "invalid value for 'notificationEndpoint', the character length must be smaller than or equal to 512.";
        }

        if (!is_null($this->container['paymentsEndpoint']) && (mb_strlen($this->container['paymentsEndpoint']) > 512)) {
            $invalidProperties[] = "invalid value for 'paymentsEndpoint', the character length must be smaller than or equal to 512.";
        }

        return $invalidProperties;
    }

    /**
     * {@inheritdoc}
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }

    /**
     * Gets approvedRedirect
     *
     * @return string
     */
    public function getApprovedRedirect()
    {
        return $this->container['approvedRedirect'];
    }

    /**
     * Sets approvedRedirect
     *
     * @param string $approvedRedirect URL of the partner used for redirection of the customer back to partner website (from Skip Pay gateway) after application approval. Do not implement any business logic on accessing this URL by customer. Implement business logic to READY notification via `notificationEndpoint`.
     *
     * @return self
     */
    public function setApprovedRedirect($approvedRedirect)
    {
        if ((mb_strlen($approvedRedirect) > 512)) {
            throw new \InvalidArgumentException('invalid length for $approvedRedirect when calling MerchantUrls., must be smaller than or equal to 512.');
        }

        $this->container['approvedRedirect'] = $approvedRedirect;

        return $this;
    }

    /**
     * Gets rejectedRedirect
     *
     * @return string
     */
    public function getRejectedRedirect()
    {
        return $this->container['rejectedRedirect'];
    }

    /**
     * Sets rejectedRedirect
     *
     * @param string $rejectedRedirect URL of the partner used for redirection of the customer back to partner website (from Skip Pay gateway) after application rejection.  Do not implement any business logic on accessing this URL by customer. Implement business logic to REJECTED notification via `notificationEndpoint`.
     *
     * @return self
     */
    public function setRejectedRedirect($rejectedRedirect)
    {
        if ((mb_strlen($rejectedRedirect) > 512)) {
            throw new \InvalidArgumentException('invalid length for $rejectedRedirect when calling MerchantUrls., must be smaller than or equal to 512.');
        }

        $this->container['rejectedRedirect'] = $rejectedRedirect;

        return $this;
    }

    /**
     * Gets notificationEndpoint
     *
     * @return string
     */
    public function getNotificationEndpoint()
    {
        return $this->container['notificationEndpoint'];
    }

    /**
     * Sets notificationEndpoint
     *
     * @param string $notificationEndpoint URL of the partner used as a notification endpoint for obtaining important updates about application (approval, rejection, storno, etc.).
     *
     * @return self
     */
    public function setNotificationEndpoint($notificationEndpoint)
    {
        if ((mb_strlen($notificationEndpoint) > 512)) {
            throw new \InvalidArgumentException('invalid length for $notificationEndpoint when calling MerchantUrls., must be smaller than or equal to 512.');
        }

        $this->container['notificationEndpoint'] = $notificationEndpoint;

        return $this;
    }

    /**
     * Gets paymentsEndpoint
     *
     * @return string|null
     */
    public function getPaymentsEndpoint()
    {
        return $this->container['paymentsEndpoint'];
    }

    /**
     * Sets paymentsEndpoint
     *
     * @param string|null $paymentsEndpoint URL of the partner used as a notification endpoint for obtaining information about payments connected with application.
     *
     * @return self
     */
    public function setPaymentsEndpoint($paymentsEndpoint)
    {
        if (!is_null($paymentsEndpoint) && (mb_strlen($paymentsEndpoint) > 512)) {
            throw new \InvalidArgumentException('invalid length for $paymentsEndpoint when calling MerchantUrls., must be smaller than or equal to 512.');
        }

        $this->container['paymentsEndpoint'] = $paymentsEndpoint;

        return $this;
    }

    /**
     * {@inheritdoc}
     */
    public function setAdditionalProperties(array $fields)
    {
        $fields = array_diff_key($fields, static::$attributeMap);
        foreach ($this->additionalProperties as $additional_properties) {
            unset($this->container[$additional_properties]);
        }
        $this->container += $fields;
        $keys = array_keys($fields);
        $this->additionalProperties = array_combine($keys, $keys);
    }

    /**
     * {@inheritdoc}
     */
    public function setAdditionalProperty($property, $value)
    {
        if (isset(static::$attributeMap[$property])) {
            throw new \InvalidArgumentException();
        }
        $this->additionalProperties[$property] = $property;
        $this->container[$property] = $value;
    }

    /**
     * {@inheritdoc}
     */
    public function getAdditionalProperties()
    {
        $container = $this->container;
        return array_map(function ($key) use ($container) {
            return $container[$key];
        }, $this->additionalProperties);
    }

    /**
     * {@inheritdoc}
     */
    #[\ReturnTypeWillChange]
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * {@inheritdoc}
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * {@inheritdoc}
     */
    #[\ReturnTypeWillChange]
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            throw new \RuntimeException('Appending to a model does not make sense. Provide an explicit property instead.');
        } else {
            if (!isset($this->attributeMap[$offset])) {
                $this->additionalProperties[$offset] = $offset;
            }
            $this->container[$offset] = $value;
        }
    }

    /**
     * {@inheritdoc}
     */
    #[\ReturnTypeWillChange]
    public function offsetUnset($offset)
    {
        /** @psalm-suppress PossiblyNullArrayOffset */
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
        return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     * @throws \JsonException
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT | JSON_THROW_ON_ERROR
        );
    }
}
